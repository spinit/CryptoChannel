                
{{nameVar}} = new (function(){

    var pubkey = "{{pubKey}}";

    function randomString(length) {
        return Math.round((Math.pow(36, length + 1) - Math.random() * Math.pow(36, length))).toString(36).slice(1);
    }

    var key_message = false; 
    var key_crypted = false;
    var cryptionEnable = true;
    var type = 'json';
    var token = '';
    var serverToken = '';

    function doAjax(url, data, callback, recalled)
    {

        function encrypt_message(plaintext)
        {
            var prefix = '0';
            // quando la chiave viene generata ... viene messa nel messaggio
            if (!key_message) {
                key_message = randomString(150);
                console.log('key',key_message);

                var encrypter = new JSEncrypt();
                encrypter.setPublicKey(pubkey);
                key_crypted = encrypter.encrypt(key_message);
                token = randomString(4);
            }
            if (token != serverToken) {
                var hexlen = Number(key_crypted.length).toString(16);
                prefix = hexlen.length + hexlen + key_crypted;
            }
    
            // crittazione simmetrica
            var encryptedMessage = Aes.Ctr.encrypt(plaintext, key_message, 256);
            console.log('encrypt',[plaintext, prefix]);
            // and concatenate our payload message
            var encrypted = prefix + encryptedMessage;

            return encrypted;
        }

        function decrypt_message(data)
        {
            var response = Aes.Ctr.decrypt(data, key_message, 256);
            return response;
        }

        data = data || {};
        if (data && typeof data != typeof "") {
            data = JSON.stringify(data);
        }
        var xmlhttp = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP");
        xmlhttp.onreadystatechange = function() {
            if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
                console.log(xmlhttp.getResponseHeader('Cryption-Type'));
                if (xmlhttp.getResponseHeader('Cryption-Type') == 'CryptoChannel') {
                    serverToken = xmlhttp.getResponseHeader('CryptoChannel-Token');
                    console.log('ricevuto', serverToken, token, recalled, xmlhttp.getResponseHeader('CryptoChannel-Status'));
                    console.log(xmlhttp.responseText);
                    if (serverToken != token) {
                        if (!recalled) {
                            doAjax(url, data, callback, 1);
                        } else {
                            // TODO: Gestire l'errore
                        }
                        return;

                    }
                    callback(decrypt_message(xmlhttp.responseText));
                } else {
                    if (xmlhttp.getResponseHeader('CryptoChannel-Status') == 'ERROR') {
                        if (!recalled) {
                            pubkey = xmlhttp.responseText;
                            key_message = '';
                            console.log('new symkey');
                            doAjax(url, data, callback, 1);
                        } else {
                            // TODO: Gestire l'errore
                        }
                        return;
                    }
                    callback(xmlhttp.responseText);
                }
            }
        }

        xmlhttp.open("POST", url, true);
    
        switch(type) {
            case 'json':
                xmlhttp.setRequestHeader('Content-type','application/json');
                break;
            case 'plain':
            case 'html':
            case 'text':
                xmlhttp.setRequestHeader('Content-type','text/'+type);
                break;
        }
        if (cryptionEnable) {
            var message = encrypt_message(data);
            xmlhttp.setRequestHeader("Cryption-Type", "CryptoChannel");
            xmlhttp.setRequestHeader("CryptoChannel-Token", token);
            xmlhttp.send(message);
        } else {
            xmlhttp.send(data);
        }
    }        

    this.send = doAjax;
    this.setCryption = function(a) {
        cryptionEnable = a;
    } 
    this.setType = function(a) {
        type = a;
    }
})();

